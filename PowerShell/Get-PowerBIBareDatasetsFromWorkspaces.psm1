<#
	
.SYNOPSIS
	Function: Get-PowerBIBareDatasetsFromWorkspaces
	Author: @JamesDBartlett3@techhub.social (James D. Bartlett III)

.DESCRIPTION
	Get all "bare" Power BI Datasets (datasets without a corresponding report) from selected Workspaces in parallel

.EXAMPLE
	Get-PowerBIBareDatasetsFromWorkspaces -Interactive -ThrottleLimit 4

.PARAMETER ThrottleLimit
	The maximum number of parallel processes to run.
	Defaults to 1.

.PARAMETER Interactive
	If specified, displays a grid view of Workspaces and allows the user to select which ones to scan for bare Datasets.

.NOTES
	This function does NOT require Azure AD app registration, 
	service principal creation, or any other special setup.
	The only requirements are:
		- The user must be able to run PowerShell (and install the
			MicrosoftPowerBIMgmt module, if it's not already installed).

	TODO
		- Separate verbose and debug outputs
		- HelpMessage on all parameters (https://youtu.be/UnjKVanzIOk)
		- 429 throttling (see Rui's repo and this article: https://powerbi.microsoft.com/en-us/blog/best-practices-to-prevent-getgroupsasadmin-api-timeout/)
		- Individual Datasets within a Workspace
		- Error handling and logging
		- Call Power BI REST API endpoints directly instead of MicrosoftPowerBIMgmt cmdlets
		- Service Principal authentication
		- [gc]::Collect() to free up memory
		- Testing

	ACKNOWLEDGEMENTS
		- Thanks to my wife (@likeawednesday@techhub.social) for her support and encouragement.
		- Thanks to @santisq & @seeminglyscience on PowerShell Discord for their guidance on using 
			Hashset<T>.Add() to filter out duplicates in the output.
#>

Function Get-PowerBIBareDatasetsFromWorkspaces {
	
	[CmdletBinding()]
	Param (
		[Parameter(Mandatory = $false)][int]$ThrottleLimit = 1,
		[Parameter(Mandatory = $false)][switch]$Interactive
	)
	
	begin {
		#Requires -PSEdition Core -Modules MicrosoftPowerBIMgmt, Microsoft.PowerShell.ConsoleGuiTools
	}
	
	process {
		try {
			$headers = Get-PowerBIAccessToken
		} 
		catch {
			Write-Host 'üîí Power BI Access Token required. Launching Azure Active Directory authentication dialog...'
			Start-Sleep -s 1
			Connect-PowerBIServiceAccount -WarningAction SilentlyContinue | Out-Null
			$headers = Get-PowerBIAccessToken
			if($headers) {
				Write-Host 'üîë Power BI Access Token acquired. Proceeding...'
			} else {
				Write-Host '‚ùå Power BI Access Token not acquired. Exiting...'
				Exit
			}
		} 
		finally {
			
			# If debugging, display the access token
			Write-Debug "Headers: `n $($headers.Keys)`n $($headers.Values)"
			
			# Define names of Workspaces and reports to ignore
			# Most of these are template apps and/or auto-generated by Microsoft
			[array]$ignoreWorkspaces = @(
				'Apps Catalog on Microsoft AppSource'
				, 'Azure DevOps Dashboard'
				, 'COVID-19 Global Report'
				, 'COVID-19 US Tracking Report'
				, 'Custom Visuals Exploration Tool'
				, 'Dataflow Snapshots'
				, 'Gen2 Utilization Metrics'
				, 'Microsoft 365 Usage Analytics'
				, 'Microsoft Fabric Capacity Metrics'
				, 'Microsoft Project Web App'
				, 'Office365 Usage Analytics'
				, 'Power BI JSON Theme Guide'
				, 'Power BI Premium Capacity Metrics'
				, 'Power BI Release Plan'
				, 'Template Apps Exploration Tool'
			)
			[array]$ignoreReports = @(
				'Dashboard Usage Metrics Report'
				, 'Report Usage Metrics Report'
			)
			
			# Get list of Workspaces
			$workspaces = Get-PowerBIWorkspace -Scope Organization -All -ErrorAction SilentlyContinue | 
			Where-Object {
				$_.Type -eq 'Workspace' -and
				$_.State -eq 'Active' -and
				$_.Name -notIn $ignoreWorkspaces
			} | Select-Object Name, Id | Sort-Object -Property Name
			
			# If interactive, display a grid view of Workspaces and allow the user to select which ones to scan for bare Datasets
			$workspaces = $Interactive ? ($workspaces | Out-ConsoleGridView -Title 'Select Workspaces to Scan') : $workspaces
			
			# Declare $hash as a hashset to store unique Dataset IDs (prevents duplicates in the output)
			$hash = [System.Collections.Generic.Hashset[guid]]::New()
			
			# For each Workspace, find Datasets with no corresponding report and add them to the $bareDatasets array
			$workspaces | ForEach-Object -ThrottleLimit $ThrottleLimit -Parallel {
			
				# Declare local variables
				$workspaceName = $_.Name
				$workspaceId = $_.Id
				
				# Get Datasets from the Workspace
				$workspaceDatasets = Get-PowerBIDataset -Scope Organization -WorkspaceId $workspaceId -ErrorAction SilentlyContinue |
				Where-Object {
					$_.IsRefreshable -eq $true -and
					$_.Name -notIn $ignoreReports
				} | Select-Object Name, Id, WebUrl, IsRefreshable, @{
					Name = 'WorkspaceName'; Expression = { $workspaceName }
				}, @{
					Name = 'WorkspaceId'; Expression = { $workspaceId }
				} | Sort-Object -Property Name
				
				# Get reports from the Workspace
				$workspaceReports = Get-PowerBIReport -Scope Organization -WorkspaceId $workspaceId -ErrorAction SilentlyContinue |
				Where-Object {
					$_.Name -notIn $ignoreReports -and
					$_.WebUrl -notlike '*/rdlreports/*'
				} | Select-Object Name, Id, WebUrl, ReportType, DatasetId, @{
					Name = 'WorkspaceName'; Expression = { $workspaceName }
				}, @{
					Name = 'WorkspaceId'; Expression = { $workspaceId }
				} | Sort-Object -Property Name
				
				# For each Dataset, check for any corresponding reports with the same name
				$workspaceDatasets | ForEach-Object {
					$datasetProperties = '' | Select-Object DatasetName, DatasetId, WebUrl, IsRefreshable, WorkspaceName, WorkspaceId
					$datasetName, $datasetId, $datasetWebUrl, $datasetIsRefreshable, $datasetWorkspaceName, $datasetWorkspaceId = $null
					$datasetName = $_.Name
					$datasetId = $_.Id
					$datasetWebUrl = $_.WebUrl
					$datasetIsRefreshable = $_.IsRefreshable
					$datasetWorkspaceName = $_.WorkspaceName
					$datasetWorkspaceId = $_.WorkspaceId
					
					# If no corresponding report is found, output the Dataset's properties for processing downstream
					if (!($workspaceReports | Where-Object { $_.Name -eq $datasetName -and $_.WorkspaceId -eq $datasetWorkspaceId })) {
						$datasetProperties.DatasetName = $datasetName
						$datasetProperties.DatasetId = $datasetId
						$datasetProperties.WebUrl = $datasetWebUrl
						$datasetProperties.IsRefreshable = $datasetIsRefreshable
						$datasetProperties.WorkspaceName = $datasetWorkspaceName
						$datasetProperties.WorkspaceId = $datasetWorkspaceId
						return $datasetProperties
					}
					
				}
				
			} <# 
				Check each returned object for uniqueness by adding its DatasetId property to the hashset.
				If the DatasetId is not already in the hashset, $hash.Add() will return true, and the object 
				will be returned in the output. But if the DatasetId has already been added to the hashset, 
				$hash.Add() will return false, and the duplicate object will not be returned in the output.
				#> 
				|	Where-Object { $hash.Add($_.DatasetId) }
			
		}

	}

	end {
		Write-Verbose "Total number of Bare Datasets: $($hash.Count)"
	}

}
	